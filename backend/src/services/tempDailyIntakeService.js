const { getFirestore, FieldValue } = require('firebase-admin/firestore');

const db = getFirestore();

class TempDailyIntakeService {
  constructor() {
    this.resetInfoDoc = db.collection('systemInfo').doc('dailyReset');
    this.intakeCollection = db.collection('tempDailyIntake');
    
    // Initialize service but don't block constructor
    this.initializeService().catch(err => console.error("Initialization failed", err));
  }

  async initializeService() {
    try {
      await this.checkAndResetDaily();
    } catch (error) {
      console.error('Error initializing TempDailyIntakeService:', error);
    }
  }

  async checkAndResetDaily() {
    try {
      const today = new Date().toISOString().split('T')[0];
      const doc = await this.resetInfoDoc.get();
      const lastReset = doc.exists ? doc.data().date : null;

      if (lastReset !== today) {
        await this.performDailyReset(today);
      }
    } catch (error) {
      console.error('Error checking daily reset:', error);
    }
  }

  async performDailyReset(today) {
    try {
      await this.resetInfoDoc.set({ date: today, lastReset: FieldValue.serverTimestamp() });

      const dayDocRef = this.intakeCollection.doc(today);
      const dayDoc = await dayDocRef.get();

      if (!dayDoc.exists) {
        await dayDocRef.set({
          date: today,
          totalCalories: 0,
          totalProtein: 0,
          totalCarbs: 0,
          totalFat: 0,
          lastUpdated: FieldValue.serverTimestamp()
        });
      }
      console.log(`Daily intake reset/check completed for ${today}`);
    } catch (error) {
      // Log the error but don't re-throw, to avoid crashing the server on startup
      console.error('Error performing daily reset:', error);
    }
  }

  async addFoodEntry(userId, foodData) {
    try {
      await this.checkAndResetDaily();
      const today = new Date().toISOString().split('T')[0];
      const dayDocRef = this.intakeCollection.doc(today);
      const entryCollectionRef = dayDocRef.collection('entries');

      const newEntry = {
        userId,
        ...foodData,
        addedAt: FieldValue.serverTimestamp(),
        isTemporary: true
      };

      await db.runTransaction(async (transaction) => {
        const dayDoc = await transaction.get(dayDocRef);
        if (!dayDoc.exists) {
            transaction.set(dayDocRef, {
                date: today,
                totalCalories: 0,
                totalProtein: 0,
                totalCarbs: 0,
                totalFat: 0,
            });
        }

        const newEntryRef = entryCollectionRef.doc();
        transaction.set(newEntryRef, newEntry);

        transaction.update(dayDocRef, {
          totalCalories: FieldValue.increment(foodData.calories || 0),
          totalProtein: FieldValue.increment(foodData.protein || 0),
          totalCarbs: FieldValue.increment(foodData.carbs || 0),
          totalFat: FieldValue.increment(foodData.fat || 0),
          lastUpdated: FieldValue.serverTimestamp()
        });
      });
      
      // The ID is generated by firestore, so we can't return it directly here
      // The calling function should be aware of this.
      return { ...newEntry, id: 'temp-id' };
    } catch (error) {
      console.error('Error adding food entry to temp storage:', error);
      throw new Error('Failed to add food entry to temporary storage');
    }
  }

  async getDailyIntake(userId) {
    try {
        await this.checkAndResetDaily();
        const today = new Date().toISOString().split('T')[0];
        const dayDocRef = this.intakeCollection.doc(today);
        const entriesQuery = dayDocRef.collection('entries').where('userId', '==', userId);

        const [dayDocSnapshot, entriesSnapshot] = await Promise.all([
            dayDocRef.get(),
            entriesQuery.get()
        ]);

        const entries = entriesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const userTotals = entries.reduce((totals, entry) => ({
            calories: totals.calories + (entry.calories || 0),
            protein: totals.protein + (entry.protein || 0),
            carbs: totals.carbs + (entry.carbs || 0),
            fat: totals.fat + (entry.fat || 0)
        }), { calories: 0, protein: 0, carbs: 0, fat: 0 });

        if (dayDocSnapshot.exists) {
            const data = dayDocSnapshot.data();
            return {
                date: data.date,
                entries: entries,
                totals: userTotals,
                lastUpdated: data.lastUpdated ? data.lastUpdated.toDate() : new Date()
            };
        } else {
             return { date: today, entries: [], totals: userTotals, lastUpdated: new Date() };
        }
    } catch (error) {
        console.error('Error getting daily intake from temp storage:', error);
        return { date: new Date().toISOString().split('T')[0], entries: [], totals: { calories: 0, protein: 0, carbs: 0, fat: 0 }, lastUpdated: new Date() };
    }
  }

  async removeFoodEntry(userId, entryId) {
    try {
        const today = new Date().toISOString().split('T')[0];
        const dayDocRef = this.intakeCollection.doc(today);
        const entryRef = dayDocRef.collection('entries').doc(entryId);

        await db.runTransaction(async (transaction) => {
            const entryDoc = await transaction.get(entryRef);
            if (!entryDoc.exists || entryDoc.data().userId !== userId) {
                throw new Error('Entry not found or permission denied');
            }

            const removedEntry = entryDoc.data();
            transaction.delete(entryRef);

            transaction.update(dayDocRef, {
                totalCalories: FieldValue.increment(-(removedEntry.calories || 0)),
                totalProtein: FieldValue.increment(-(removedEntry.protein || 0)),
                totalCarbs: FieldValue.increment(-(removedEntry.carbs || 0)),
                totalFat: FieldValue.increment(-(removedEntry.fat || 0)),
                lastUpdated: FieldValue.serverTimestamp()
            });
        });

        return true;
    } catch (error) {
        console.error('Error removing food entry from temp storage:', error);
        throw new Error('Failed to remove food entry from temporary storage');
    }
  }
}

module.exports = new TempDailyIntakeService();